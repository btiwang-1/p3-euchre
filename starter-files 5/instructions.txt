/*
    How the game will work:
        a. SETUP THE TABLE
            DEALER: *DONE
                In each hand, one player is designated as the dealer 
                (if humans were playing the game, the one who passes out the cards). 
                In our game, player 0 deals during the first hand. Each subsequent hand, 
                the role of dealer moves one player to the left.


            TEAMS: *DONE
                Players 0 and 2 are TEAM ONE
                Players 1 and 3 are TEAM TWO
            i. Shuffle *done
                - Call Pack::shuffle()
                * If shuffling is disabled, call Pack::reset() anytime shuffling would be called
            ii. Deal *done
                - Call Player::add_card(Pack::dealOne()) for every card you want to give a player, *It returns a Card*
                - Remember 3-2-3-2 and then 2-3-2-3; Each player gets 5 cards in the end.

                - Four cards remain in the deck after the deal. 
                    The NEXT card in the pack is called the UPCARD 
                    (it is turned face up, while the other cards are all face down)
        b. MAKING TRUMP *Fully Implemented? 
            i. Round One
                
                - Ordering Up! Starts with the Player to the left of the dealer
                    and goes around the circle to see if anyone wants to order up or pass
                - Should someone order up, the suit of the UPCARD becomes the TRUMP SUIT (Use Player::make_trump())
                - The dealer has the opportunity to replace one of their cards with the UPCARD
            ii. Round Two
                - If all players pass the first round, We do another making
                - The UPCARD's suit is rejected and cannot be ordered up. Instead, 
                    the players may order up any suit other than the UPCARD's suit.
                    (Using the same rotation as round one starting at the eldest hand)
                - If making reaches the dealer during the second round, a variant called 
                    screw the dealer is invoked: the dealer must order up a suit other than 
                    the rejected suit. (Must we program this part?)

        c. TRICK TAKING (NEED TO COMPLETE)
            - Once the trump is determined, we go through FIVE tricks: 
            Trick: Players take turns laying down cards, highest card wins the trick (Use Card::Card_less)
            - Person who plays first becomes LEADER
            * For the 1st Trick, the ELDEST HAND leads

            TRICKS:
                1. Leader leads any of their cards (the suit off that card becomes the led_suit)
                2. Each player must follow suit if they can but must put something down regardless
                3. Play moves to the left around the table, with each player playing one card.
            - The winner of the trick leads the next trick.
        d. SCORING *Done, just need to specify march and euchred in print
            i. If the team that ordered up the trump suit takes 3 or 4 tricks, they get 1 point.
            ii. If the team that ordered up the trump suit takes all 5 tricks, they get 2 points. This is called a MARCH.
            iii. If the team that did not order up takes 3, 4, or 5 tricks, they receive 2 points. This is called EUCHRED.
*/

#include "Player.hpp"
#include <vector>
#include <string>
#include <cassert>
#include <iostream>

class SimplePlayer : public Player {
  public:
    SimplePlayer(const std::string &name_in) : name{name_in} {}
    const std::string & get_name() const {
      return name;
    }

    void add_card(const Card &c) {
      assert(MAX_HAND_SIZE > allCards.size());
      allCards.push_back(c);
    }

    bool make_trump(const Card &upcard, bool is_dealer, int round, Suit &order_up_suit) const {
      Suit trumpSuit = upcard.get_suit(); 
      if(round == 1) {
        int faceCheckCounter = 0;
        for(size_t i = 0; i < allCards.size(); ++i) {
          if(allCards[i].get_suit() == trumpSuit && allCards[i].is_face_or_ace()) {
            faceCheckCounter++;
          }
        }
        if(faceCheckCounter >= 2) {
          order_up_suit = trumpSuit;
          return true;
        } else {
          return false;
        }
      } else {
        int faceOrAceCheckCounterTwo = 0;
        Suit sameColor = Suit_next(trumpSuit); 
        for(size_t i = 0; i < allCards.size(); ++i) {
          if(allCards[i].get_suit(sameColor) == sameColor && allCards[i].is_face_or_ace()) {
            faceOrAceCheckCounterTwo++;
          }
        }
        if(faceOrAceCheckCounterTwo >= 1) {
          order_up_suit = sameColor;
          return true;
        } else if(is_dealer == true) {
          order_up_suit = sameColor;
          return true;
        } else {return false;}
        
      }
    }

    void add_and_discard(const Card &upcard) {
      assert(allCards.size() >= 1);
      allCards.push_back(upcard);
      int worstCardIndex = 0;
      Suit trumpSuit = upcard.get_suit();
      for(size_t i = 1; i < allCards.size(); ++i) {
        if(Card_less(allCards[i], allCards[worstCardIndex], trumpSuit)) {
          worstCardIndex = i;
        }
      }
      allCards.erase(allCards.begin() + worstCardIndex);
    }

    Card lead_card(Suit trump) {
        int ind = -1;
        for (size_t i = 0; i < allCards.size(); i++) {
            if (!allCards[i].is_trump(trump)) {
                if (ind == -1 || Card_less(allCards[ind], allCards[i], trump)) {
                    ind = i;
                }
            }
        }
        if (ind == -1) {
            ind = 0;
            for (size_t i = 1; i < allCards.size(); ++i) {
                if (Card_less(allCards[ind], allCards[i], trump)) {
                    ind = i;
                }
            }
        }
        
        Card led = allCards[ind];
        allCards.erase(allCards.begin() + ind);
        return led;
    }

    Card play_card(const Card &led_card, Suit trump) {
        int ind = -1;
        Suit led_suit = led_card.get_suit(trump);

        for (size_t i = 0; i < allCards.size(); i++){
            if (allCards[i].get_suit() == led_suit){
                if (ind == -1 || Card_less(allCards[ind],allCards[i],led_card,trump)){
                    ind = i;
                }
            }
        }
        
        if (ind == -1){
            ind = 0;
            for (size_t i = 1; i < allCards.size(); i++){
                if (Card_less(allCards[i],allCards[ind],led_card,trump)){
                    ind = i;
                }
            }
        }
        
    
        Card play = allCards[ind];
        allCards.erase(allCards.begin() + ind);
        return play;
    }
    
  private:
    std::string name;
    std::vector<Card> allCards;
};

class HumanPlayer : public Player {
  public:
    HumanPlayer(const std::string &name_in) : name(name_in) {}

    const std::string & get_name() const {
        return name;
    }

    void add_card(const Card &c) {
      assert(MAX_HAND_SIZE > allCards.size());
      allCards.push_back(c);
    }

    bool make_trump(const Card &upcard, bool is_dealer, int round, Suit &order_up_suit) const {
      print_hand();
      std::cout << "Human player " << name << ", please enter a suit, or \"pass\":\n";
      std::string decision;
      std::cin >> decision;
      if(decision != "pass") {
        order_up_suit = string_to_suit(decision);
        return true;
      } else {
        return false;
      }
    }

    void add_and_discard(const Card &upcard)  {
      allCards.push_back(upcard);
      print_hand();
      std::cout << "Discard upcard: [-1]\n";
      std::cout << "Human player " << name << ", please select a card to discard:\n";
      int chosenIndex;
      std::cin >> chosenIndex;
      if(chosenIndex == -1) {
        allCards.pop_back();
      } else {
        allCards.erase(allCards.begin() + chosenIndex);
      }


    }

    Card lead_card(Suit trump)  {
        print_hand();
        std::cout << "Human player " << name << ", please select a card:\n";
        int crd;
        std::cin >> crd;
        Card chosenCrd = allCards[crd];
        allCards.erase(allCards.begin() + crd);
        return chosenCrd;
    }

    Card play_card(const Card &led_card, Suit trump)  {
        print_hand();
        std::cout << "Human player " << name << ", please select a card:\n";
        int crd;
        std::cin >> crd;
        Card chosenCrd = allCards[crd];
        allCards.erase(allCards.begin() + crd);
        return chosenCrd;
    }
    
  private:
    std::string name;
    std::vector<Card> allCards;
    void print_hand() const {
        for (size_t i=0; i < allCards.size(); ++i){
            std::cout << "Human player " << name << "'s hand: "
                << "[" << i << "] " << allCards[i] << "\n";
        }
    }
};


//EFFECTS: Returns a pointer to a player with the given name and strategy
//To create an object that won't go out of scope when the function returns,
//use "return new Simple(name)" or "return new Human(name)"
//Don't forget to call "delete" on each Player* after the game is over
Player * Player_factory(const std::string &name, const std::string &strategy) {
  if (strategy == "Simple") {
    // The "new" keyword dynamically allocates an object.
    return new SimplePlayer(name);
  } else if(strategy == "Human") {
    return new HumanPlayer(name);
  }
  assert(false);
  return nullptr;
}

//EFFECTS: Prints player's name to os
std::ostream & operator<<(std::ostream &os, const Player &p) {
  os << p.get_name();
  return os;
}